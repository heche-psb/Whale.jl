<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Whale.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Whale.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Sliced-species-tree-1">Sliced species tree</a></li><li><a class="toctext" href="#Conditional-clade-distribution(s)-1">Conditional clade distribution(s)</a></li><li><a class="toctext" href="#The-WhaleModel-1">The <code>WhaleModel</code></a></li><li><a class="toctext" href="#Maximum-likelihood-estimation-1">Maximum likelihood estimation</a></li><li><a class="toctext" href="#Bayesian-inference-1">Bayesian inference</a></li><li><a class="toctext" href="#Backtracking-and-consensus-reconciled-trees-1">Backtracking and consensus reconciled trees</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/arzwa/Whale.jl/blob/master/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><p>Below the major components of the Whale library are discussed.</p><h2><a class="nav-anchor" id="Sliced-species-tree-1" href="#Sliced-species-tree-1">Sliced species tree</a></h2><p>The ALE approach to probabilistic gene tree - species tree reconciliation uses a discretization of the branches of the species tree into small time intervals. This &#39;sliced&#39; species tree defines the main structure of the model.</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree()
SlicedTree(9, 17, 7)

julia&gt; st.tree
Phylogenetic tree with 24 nodes and 23 branches

julia&gt; st.leaves
Dict{Int64,String} with 9 entries:
  4  =&gt; &quot;PPAT&quot;
  13 =&gt; &quot;CPAP&quot;
  10 =&gt; &quot;OSAT&quot;
  14 =&gt; &quot;ATRI&quot;
  3  =&gt; &quot;MPOL&quot;
  16 =&gt; &quot;GBIL&quot;
  17 =&gt; &quot;PABI&quot;
  6  =&gt; &quot;SMOE&quot;
  12 =&gt; &quot;ATHA&quot;

julia&gt; wgds(st)  # WGD ID → WGD node → q index
PPAT → node 18 → q1
CPAP → node 19 → q2
BETA → node 20 → q3
ANGI → node 21 → q4
SEED → node 22 → q5
MONO → node 23 → q6
ALPH → node 24 → q7

julia&gt; st[3, 4]  # length of 4th slice in branch 3
0.049499999999999995

julia&gt; nslices(st, 3)  # number of slices in branch 3
97</code></pre><p>To get a tree in Newick format into a <code>SlicedTree</code>, one can simply use <code>SlicedTree(tree_file)</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Note that the tree is assumed to be <strong>ultrametric</strong> and that you might need to change the default <code>Δt</code> value for your purposes. WGDs can be specified by using a configuration dictionary (see <a href="../api/#Whale.SlicedTree"><code>SlicedTree</code></a>).</p></div></div><p>For visualizing tree structures, the <a href="https://github.com/arzwa/PalmTree.jl"><code>PalmTree</code></a> library can be used. It is often useful for example to plot the tree with internal node labels for specifying models in Whale</p><pre><code class="language-julia-repl">julia&gt; using PalmTree
julia&gt; drawtree(st, nodelabels=true)</code></pre><p>Here, nodes 18 to 24 are WGD &#39;nodes&#39;, marking hypothetical WGDs along the sliced species tree.</p><p><img src="../assets/example_tree.svg" alt/></p><h3><a class="nav-anchor" id="Rate-indices-1" href="#Rate-indices-1">Rate indices</a></h3><p>The <code>SlicedTree</code> structure has two fields that store mappings from nodes/branches in the tree to indices in hypothetical parameter vectors. The <code>qindex</code> field is a mapping (Dict) from WGD nodes to indiced for a vector of retention rates, whereas the <code>rindex</code> serves as a mapping from species tree branches to indices for the duplication and loss rate vectors. The default <code>rindex</code> has a different index for each branch of the species tree, and with the same index for the part of a branch before and after a WGD (note that branches are identified by the index of there downstream (leafward) node).</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; st.qindex
Dict{Int64,Int64} with 7 entries:
  20 =&gt; 3
  23 =&gt; 6
  24 =&gt; 7
  19 =&gt; 2
  21 =&gt; 4
  22 =&gt; 5
  18 =&gt; 1

julia&gt; st.rindex
Dict{Int64,Int64} with 24 entries:
  18 =&gt; 4
  2  =&gt; 2
  16 =&gt; 16
  11 =&gt; 11
  21 =&gt; 8
  7  =&gt; 7
  9  =&gt; 9
  10 =&gt; 10
  19 =&gt; 13
  17 =&gt; 17
  8  =&gt; 8
  22 =&gt; 7
  6  =&gt; 6
  24 =&gt; 12
  4  =&gt; 4
  3  =&gt; 3
  5  =&gt; 5
  20 =&gt; 12
  23 =&gt; 10
  ⋮  =&gt; ⋮</code></pre><p>In this example, branches 20, 24 and 12 (which are all part of the same species tree branch but refer to different segments marked by WGD nodes) all point to index 12, which means that they are associated with the same duplication and loss rates.</p><p>The <code>rindex</code> can be modified to specify arbitrary rate models (for instance fixing a particular clade to a one shared duplication and loss rate). In order to specify a consjuliatant-rates model, one can do</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; set_constantrates!(st)

julia&gt; st.rindex
Dict{Int64,Int64} with 24 entries:
  18 =&gt; 1
  2  =&gt; 1
  16 =&gt; 1
  11 =&gt; 1
  21 =&gt; 1
  7  =&gt; 1
  9  =&gt; 1
  10 =&gt; 1
  19 =&gt; 1
  17 =&gt; 1
  8  =&gt; 1
  22 =&gt; 1
  6  =&gt; 1
  24 =&gt; 1
  4  =&gt; 1
  3  =&gt; 1
  5  =&gt; 1
  20 =&gt; 1
  23 =&gt; 1
  ⋮  =&gt; ⋮</code></pre><h2><a class="nav-anchor" id="Conditional-clade-distribution(s)-1" href="#Conditional-clade-distribution(s)-1">Conditional clade distribution(s)</a></h2><p>The conditional clade distributions (CCDs) for a set of gene families provide the main input data (observations) for Whale analyses. These can be read from <code>.ale</code> files generated by <a href="https://github.com/ssolo/ALE"><code>ALEobserve</code></a>. The <code>read_ale</code> function accepts either a single <code>.ale</code> file, a text file with on each line the path to a <code>.ale</code> file or a directory of <code>.ale</code> files. When an empty file is provided, a dummy CCD object will be created (which is useful when one wants to run an MCMC chain without data to check the prior specification).</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; ccd = read_ale(&quot;../example/example-ale/&quot;, st)
[ Info:  .. read 12 ALE files
12-element DistributedArrays.DArray{CCD,1,Array{CCD,1}}:
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 83 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 55 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 89 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 131 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 107 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 59 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 53 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 83 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 59 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 95 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 67 clades, 5001 samples)
 CCD{Float64,PhyloTrees.RecTree}(13 taxa, 65 clades, 5001 samples)</code></pre><p>By default, <code>read_ale</code> will distribute the resulting CCD array over all available processors.</p><h2><a class="nav-anchor" id="The-WhaleModel-1" href="#The-WhaleModel-1">The <code>WhaleModel</code></a></h2><p>The last object of importance to do inference with <code>Whale</code> is the <code>WhaleModel</code> type. This structure is used for computing the probability of observing the data conditional on the model and its parameters (<code>logpdf</code>).</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; ccd = read_ale(&quot;../example/example-ale/&quot;, st);
[ Info:  .. read 12 ALE files

julia&gt; w = WhaleModel(st)
WhaleModel{Float64,CCD}(
λ: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
μ: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]
q: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
η: 0.9
)

julia&gt; logpdf(w, ccd[1])  # single CCD
-32.70481615232666

julia&gt; logpdf(w, ccd)     # multiple CCDs, distributed by default
-298.98170493684256

julia&gt; w = WhaleModel(st, rand(17), rand(17), rand(7), 0.66)  # full constructor
WhaleModel{Float64,CCD}(
λ: [0.590845, 0.766797, 0.566237, 0.460085, 0.794026, 0.854147, 0.200586, 0.298614, 0.246837, 0.579672, 0.648882, 0.0109059, 0.066423, 0.956753, 0.646691, 0.112486, 0.276021]
μ: [0.651664, 0.0566425, 0.842714, 0.950498, 0.96467, 0.945775, 0.789904, 0.82116, 0.0341601, 0.0945445, 0.314926, 0.12781, 0.374187, 0.931115, 0.438939, 0.246862, 0.0118196]
q: [0.0460428, 0.496169, 0.732, 0.299058, 0.449182, 0.875096, 0.0462887]
η: 0.66
)

julia&gt; logpdf(w, ccd)
-370.067694892539</code></pre><p>An informative description of the model can be printed using <code>describe</code></p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; w = WhaleModel(st);

julia&gt; describe(w)
Leaves
======
4 	→ PPAT
13 	→ CPAP
10 	→ OSAT
14 	→ ATRI
3 	→ MPOL
16 	→ GBIL
17 	→ PABI
6 	→ SMOE
12 	→ ATHA
Rates (λ, μ)
============
3 	| λ, μ = 0.2,0.3	| (3)
4 	| λ, μ = 0.2,0.3	| (4)
18 	| λ, μ = 0.2,0.3	| (4)
2 	| λ, μ = 0.2,0.3	| (4,3)
6 	| λ, μ = 0.2,0.3	| (6)
16 	| λ, μ = 0.2,0.3	| (16)
17 	| λ, μ = 0.2,0.3	| (17)
15 	| λ, μ = 0.2,0.3	| (16,17)
13 	| λ, μ = 0.2,0.3	| (13)
19 	| λ, μ = 0.2,0.3	| (13)
12 	| λ, μ = 0.2,0.3	| (12)
24 	| λ, μ = 0.2,0.3	| (12)
20 	| λ, μ = 0.2,0.3	| (12)
11 	| λ, μ = 0.2,0.3	| (13,12)
10 	| λ, μ = 0.2,0.3	| (10)
23 	| λ, μ = 0.2,0.3	| (10)
9 	| λ, μ = 0.2,0.3	| (13,10,12)
14 	| λ, μ = 0.2,0.3	| (14)
8 	| λ, μ = 0.2,0.3	| (13,10,14,12)
21 	| λ, μ = 0.2,0.3	| (13,10,14,12)
7 	| λ, μ = 0.2,0.3	| (13,10,14,16,17,12)
22 	| λ, μ = 0.2,0.3	| (13,10,14,16,17,12)
5 	| λ, μ = 0.2,0.3	| (13,10,14,16,17,6,12)
1 	| λ, μ = 0.2,0.3	| (4,13,10,14,3,16,17,6,12)
WGDs (q)
========
20, q = 0.2
23, q = 0.2
24, q = 0.2
19, q = 0.2
21, q = 0.2
22, q = 0.2
18, q = 0.2
Other
=====
   η = 0.9
cond = oib</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The default initial rate values (~0.2) might not be appropriate for you data set and lead to numerical difficulties. Good initial values depend on the unit of time the branch lengths of the <code>SlicedTree</code> are expressed in.</p></div></div><h2><a class="nav-anchor" id="Maximum-likelihood-estimation-1" href="#Maximum-likelihood-estimation-1">Maximum likelihood estimation</a></h2><p>Maximum likelihood estimation is performed using <code>Optim.jl</code> with <code>ForwardDiff.jl</code> automatic differentiation. By default the <code>LBFGS</code> optimizer is used, but other Optimizers from Optim work as well.</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; set_constantrates!(st)

julia&gt; w = WhaleModel(st, 0.2, 0.3)
WhaleModel{Float64,CCD}(
λ: [0.2]
μ: [0.3]
q: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
η: 0.9
)

julia&gt; mle(w, ccd)
Fminbox
-------
Initial mu = 0.0038519

Fminbox iteration 1
-------------------
Calling inner optimizer with mu = 0.0038519

(numbers below include barrier contribution)
Iter     Function value   Gradient norm
     0     2.990420e+02     9.056730e+01
    10     2.788972e+02     3.959786e+00
  ... # a lot more
, Results of Optimization Algorithm
 * Algorithm: Fminbox with L-BFGS
 * Starting Point: [0.2,0.3,0.2,0.2,0.2,0.2,0.2,0.2,0.2]
 * Minimizer: [0.08839734901061815,0.15058644779285166, ...]
 * Minimum: 2.787698e+02
 * Iterations: 6
 * Convergence: true
   * |x - x&#39;| ≤ 0.0e+00: true
     |x - x&#39;| = 0.00e+00
   * |f(x) - f(x&#39;)| ≤ 0.0e+00 |f(x)|: true
     |f(x) - f(x&#39;)| = 0.00e+00 |f(x)|
   * |g(x)| ≤ 1.0e-08: false
     |g(x)| = 1.38e+01
   * Stopped by an increasing objective: true
   * Reached Maximum Number of Iterations: false
 * Objective Calls: 1755
 * Gradient Calls: 1755)</code></pre><h2><a class="nav-anchor" id="Bayesian-inference-1" href="#Bayesian-inference-1">Bayesian inference</a></h2><p>Currently, a model-specific MCMC algorithm (following an adaptive metropolis-within-Gibbs scheme) is used. Specifying arbitrary complex models in <code>Turing.jl</code> is possible, but currently does not support distributed likelihood evaluation and is therefore not yet possible for the kinds of problems tackled with Whale. This is a major goal for future developments.</p><h3><a class="nav-anchor" id="Independent-rates-model-1" href="#Independent-rates-model-1">Independent rates model</a></h3><p>The default structure of the independent rates model is as follows.</p><div>\[\begin{eqnarray}
\nu &amp;\sim&amp; \mathrm{InverseGamma} \\
\eta &amp;\sim&amp; \mathrm{Beta} \\
\lambda_0 &amp;\sim&amp; \mathrm{Exponential} \\
\mu_0 &amp;\sim&amp; \mathrm{Exponential} \\
\lambda_i &amp;\sim&amp; \mathrm{LogNormal}(\lambda_0, \nu) \\
\mu_i &amp;\sim&amp; \mathrm{LogNormal}(\mu_0, \nu) \\
q_i &amp;\sim&amp; \mathrm{Beta}(1, 1)
\end{eqnarray}\]</div><p>But other distributions from the <code>Distributions.jl</code> library can be used. It is also possible to set parameters to fixed values. This is often desirable for either <code>η</code> or <code>ν</code> to ensure proper mixing of the chain.</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree()
SlicedTree(9, 17, 7)

julia&gt; w = WhaleChain(st, IRModel())
WhaleChain{IRModel{Distributions.InverseGamma{Float64},Distributions.Beta{Float64},Distributions.Exponential{Float64},Distributions.Exponential{Float64},Distributions.Beta{Float64}}}(SlicedTree(9, 17, 7))</code></pre><p>To run the MCMC simulation, use the <code>mcmc!</code> function</p><pre><code class="language-julia-repl">julia&gt; chain = mcmc!(w, D, 100, show_every=10)</code></pre><p>The resulting <code>Chains</code> object is fairly intuitive, see the docs for <a href="https://github.com/TuringLang/MCMCChains.jl"><code>MCMCChains.jl</code></a>.</p><h3><a class="nav-anchor" id="Autocorrelated-rates-model-(Geometric-Brownian-motion)-1" href="#Autocorrelated-rates-model-(Geometric-Brownian-motion)-1">Autocorrelated rates model (Geometric Brownian motion)</a></h3><p>The default structure is as above but with</p><div>\[\begin{eqnarray}
\nu &amp;\sim&amp; \mathrm{Exponential} \\
\eta &amp;\sim&amp; \mathrm{Beta} \\
\lambda_0 &amp;\sim&amp; \mathrm{Exponential} \\
\mu_0 &amp;\sim&amp; \mathrm{Exponential} \\\lambda_i &amp;\sim&amp; \mathrm{GeometricBrownianMotion}(\lambda_0, \nu) \\
\mu_i &amp;\sim&amp; \mathrm{GeometricBrownianMotion}(\mu_0, \nu) \\
q_i &amp;\sim&amp; \mathrm{Beta}(1, 1)
\end{eqnarray}\]</div><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree()
julia&gt; w = WhaleChain(st, GBMModel(st))
julia&gt; chain = mcmc!(w, D, 100, show_every=10)</code></pre><h3><a class="nav-anchor" id="MCMC-mixing-issues-1" href="#MCMC-mixing-issues-1">MCMC mixing issues</a></h3><p>When WGD hypotheses and branch-wise rates across the tree are combined, MCMC in the Whale model can be quite sensitive to the (informative) priors used. For some data sets and prior settings the MCMC algorithm may have a hard time converging, or some parameter may wander of in an unrealistic area of parameter space. Since there is usually a lot of data, the influence of the prior is often very limited and the likelihood dominates the posterior (which is of course desirable), and it may be necessary to constrain some elements of the model to attain convergence.</p><h4><a class="nav-anchor" id="Fixing-η-and/or-ν-1" href="#Fixing-η-and/or-ν-1">Fixing <code>η</code> and/or <code>ν</code></a></h4><p>To prevent poor mixing in the MCMC, it is often necessary to fix the <code>η</code> and/or <code>ν</code> parameters. For <code>η</code> this is usually not very problematic, since it embodies already a distributional assumption that allows for uncertainty in prior beliefs (since it is the parameter of the geometric prior distribution  on the number of lineages at the root). Choosing for instance <code>η = 0.8</code>, The probability of one lineage at the root is 0.8, two lineages 0.16, three lineages  0.032 etc.</p><p>Fixing <code>ν</code> (which controls the variation in duplication and loss rates across lineages) can be more troublesome since it is hard to specify a cogent prior. In the context of WGD inference however, the &#39;true&#39; values of the duplication and loss rates might not matter too much, and we are mostly interested whether allowing more rate variation across the tree alters are posterior beliefs with regard to WGDs. When the goal is WGD inference, it is therefore advisable to run chains for different <code>ν</code> values and see whether this alters the posterior distributions for the retention rates. Often when the rates are constrained to be very similar across the tree (small <code>ν</code> values), some duplication/loss rate variation is captured by the retention rate, and in this case, for larger <code>ν</code> values, a previously significant non-zero retention rate might shift towards zero.</p><p>Below the chain is fixed for the parameter values η=0.9 and ν=0.1.</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree()
julia&gt; w = WhaleChain(st, IRModel(ν=Whale.ConstantDistribution(0.1), η=Whale.ConstantDistribution(0.9)))
julia&gt; chain = mcmc!(w, D, 100, :ν, :η, show_every=10)</code></pre><h4><a class="nav-anchor" id="Constraining-rates-on-branches-stemming-from-the-root-1" href="#Constraining-rates-on-branches-stemming-from-the-root-1">Constraining rates on branches stemming from the root</a></h4><p>Sometimes, in particular when there is a long outgroup branch (possibly with WGDs), it can help to constrain the branches stemming left and right from the root of the species tree to have the same duplication and loss rates. This can be done as follows:</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree();

julia&gt; set_equalrootrates!(st);

julia&gt; st.rindex
Dict{Int64,Int64} with 24 entries:
  18 =&gt; 4
  2  =&gt; 2
  16 =&gt; 15
  11 =&gt; 10
  21 =&gt; 7
  7  =&gt; 6
  9  =&gt; 8
  10 =&gt; 9
  19 =&gt; 12
  17 =&gt; 16
  8  =&gt; 7
  22 =&gt; 6
  6  =&gt; 5
  24 =&gt; 11
  4  =&gt; 4
  3  =&gt; 3
  5  =&gt; 2
  20 =&gt; 11
  23 =&gt; 9
  ⋮  =&gt; ⋮
</code></pre><h3><a class="nav-anchor" id="Sampling-from-the-prior-1" href="#Sampling-from-the-prior-1">Sampling from the prior</a></h3><p>It is generally advisable to run a chain without data, to investigate the prior distributions one has assigned, and validate the correctness of the MCMC algorithm. This can be done as follows:</p><pre><code class="language-julia-repl">julia&gt; st = Whale.example_tree()
julia&gt; w = WhaleChain(st, IRModel())
julia&gt; chain = mcmc!(w, 10000)</code></pre><h2><a class="nav-anchor" id="Backtracking-and-consensus-reconciled-trees-1" href="#Backtracking-and-consensus-reconciled-trees-1">Backtracking and consensus reconciled trees</a></h2><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Backtracking functionalities are still quite experimental and prone to change.</p></div></div><p>To backtrack reconciled trees for a particular CCD from a parameterized <code>WhaleModel</code> and compute majority-vote consensus trees one can use the following methods</p><pre><code class="language-julia-repl">julia&gt; x  # a single CCD
CCD{Float64,PhyloTrees.RecTree}(13 taxa, 83 clades, 5001 samples)

julia&gt; w = WhaleModel(st, 0.2, 0.3)
WhaleModel{Float64,CCD}(
λ: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
μ: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]
q: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
η: 0.9
)

julia&gt; backtrack!(x, w, 100)
CCD{Float64,PhyloTrees.RecTree}(13 taxa, 83 clades, 5001 samples)

julia&gt; drawtree(x.rectrs[1)</code></pre><p><img src="../assets/example_rectree.svg" alt/></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently the branch lengths in backtracked trees are not yet meaningful, although they are related to the branch lengths in the CCD.</p></div></div><p>Majority vote consensus trees can than be obtained</p><pre><code class="language-julia-repl">julia&gt; contree = consensus(x, st)
Phylogenetic tree with 25 nodes and 24 branches, [...]

julia&gt; drawtree(contree)</code></pre><p><img src="../assets/example_conrectree.svg" alt/></p><p>Reconciled trees are stored in the <code>rectrs</code> field of the CCD object. By default, during MCMC, every iteration a tree is sampled from the posterior predictive distribution.</p><pre><code class="language-julia-repl">julia&gt; D = read_ale(&quot;example/example-ale/&quot;, st);
[ Info:  .. read 12 ALE files

julia&gt; w = WhaleChain(st, IRModel(st, 0.1, 0.9));

julia&gt; chain = mcmc!(w, D, 100, :ν, :η);

julia&gt; crts = consensus(D, st);</code></pre><p>(Consensus) reconciled trees can be written in a newick-like format, where support values <code>x1-x2</code> with <code>x1</code> the clade support, which is the frequency by which the clade was observed in the sample of reconciled trees, and <code>x2</code> the reconciliation support, being the frequency of this nodes majority vote reconciliation (e.g. duplication or speciation). Note that loss events do not appear in consensus reconciliations (but they can be easily determined based on the reconciliations of other nodes).</p><pre><code class="language-julia">julia&gt; write(stdout, crts[1])
(((PABI_PAB00009793.1_PAB00009793,((((CPAP_Cpa.t.sc25.3_Cpa.g.sc25.3,((CPAP_Cpa.t.sc25.8_Cpa.g.sc25.8,CPAP_Cpa.t.sc25.5_Cpa.g.sc25.5)0.6086956521739131-0.33043478260869563,ATHA_AT5G48120.1_AT5G48120)0.5391304347826087-0.5043478260869565)0.9217391304347826-0.6173913043478261,(OSAT_LOC_Os07g08050.1_LOC_Os07g08050,CPAP_Cpa.t.sc25.4_Cpa.g.sc25.4)0.9043478260869565-0.9043478260869565)1.0-0.9304347826086956,ATRI_ATR0705G185.1_ATR0705G185)1.0-0.991304347826087,(PABI_PAB00012681.1_PAB00012681,GBIL_Gb_13638)1.0-0.9826086956521739)0.991304347826087-0.991304347826087)1.0-0.33043478260869563,SMOE_SMO111G0185.1_SMO111G0185)1.0-0.991304347826087,(MPOL_Mapoly0036s0119.1_Mapoly0036s0119,PPAT_Pp3c9_4950V3.1_Pp3c9_4950)1.0-1.0);</code></pre><p>(Consensus) reconciled trees can also be written in <a href="http://phylariane.univ-lyon1.fr/recphyloxml/">PhyloRecXML</a> format:</p><pre><code class="language-none">julia&gt; write(stdout, crts[1], st, family=D[1].fname)
&lt;recGeneTree
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://www.recgenetreexml.org&quot; &quot;txsi:schemaLocation=&quot;http://www.recgenetreexml.org ../../xsd/recGeneTreeXML.xsd&quot;&gt;
    &lt;phylogeny rooted=&quot;true&quot;&gt;
        &lt;id&gt;example/example-ale/OG0004512.fasta.nex.treesample.ale&lt;/id&gt;
        &lt;clade&gt;
            &lt;name&gt;1&lt;/name&gt;
            &lt;eventsRec&gt;&lt;speciation speciesLocation=&quot;1&quot;&gt;&lt;/speciation&gt;&lt;/eventsRec&gt;
            &lt;clade&gt;
                &lt;name&gt;2&lt;/name&gt;
                &lt;eventsRec&gt;&lt;speciation speciesLocation=&quot;5&quot;&gt;&lt;/speciation&gt;&lt;/eventsRec&gt;
                &lt;clade&gt;
                    &lt;name&gt;3&lt;/name&gt;
                    &lt;eventsRec&gt;&lt;duplication speciesLocation=&quot;7&quot;&gt;&lt;/duplication&gt;&lt;/eventsRec&gt;
                    &lt;clade&gt;
                        &lt;name&gt;PABI_PAB00009793.1_PAB00009793&lt;/name&gt;
                        &lt;eventsRec&gt;&lt;leaf speciesLocation=&quot;PABI&quot; geneName=&quot;PABI_PAB00009793.1_PAB00009793&quot;&gt;&lt;/leaf&gt;&lt;/eventsRec&gt;
                    &lt;/clade&gt;
                    [...]  # a lot more
                    &lt;/clade&gt;
               &lt;clade&gt;
                   &lt;name&gt;PPAT_Pp3c9_4950V3.1_Pp3c9_4950&lt;/name&gt;
                   &lt;eventsRec&gt;&lt;leaf speciesLocation=&quot;PPAT&quot; geneName=&quot;PPAT_Pp3c9_4950V3.1_Pp3c9_4950&quot;&gt;&lt;/leaf&gt;&lt;/eventsRec&gt;
               &lt;/clade&gt;
           &lt;/clade&gt;
       &lt;/clade&gt;
   &lt;/phylogeny&gt;
&lt;/recGeneTree&gt;</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
