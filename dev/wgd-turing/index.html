<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayesian inference using Turing.jl · Whale.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Whale.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../wgd-dhmc/">Bayesian inference using NUTS with <code>DynamicHMC.jl</code></a></li><li class="current"><a class="toctext" href>Bayesian inference using <code>Turing.jl</code></a><ul class="internal"><li><a class="toctext" href="#Using-a-constant-rates-model-1">Using a constant-rates model</a></li><li><a class="toctext" href="#Using-a-branch-specific-rates-model-1">Using a branch-specific rates model</a></li></ul></li><li><a class="toctext" href="../cytp450/">Reconciled tree inference example</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Bayesian inference using <code>Turing.jl</code></a></li></ul><a class="edit-page" href="https://github.com/arzwa/Whale.jl/blob/master/docs/src/wgd-turing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Bayesian inference using Turing.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Bayesian-inference-using-Turing.jl-1" href="#Bayesian-inference-using-Turing.jl-1">Bayesian inference using <code>Turing.jl</code></a></h1><p>In this example we will use the probabilistic programming language implemented in <a href="https://turing.ml/dev/"><code>Turing.jl</code></a> with Whale to specify Bayesian hierarchical models for gene tree reconciliation in a flexible way</p><div><pre><code class="language-julia">using Whale, NewickTree, Distributions, Turing, DataFrames, LinearAlgebra, Random
Random.seed!(7137);</code></pre></div><h2><a class="nav-anchor" id="Using-a-constant-rates-model-1" href="#Using-a-constant-rates-model-1">Using a constant-rates model</a></h2><p>First we will do inference for a simple constant-rates model (i.e. assuming a single duplication and loss rate for the entire species tree). First we load the species tree (using the example tree available in the WHale library)</p><div><pre><code class="language-julia">t = deepcopy(Whale.extree)
n = length(postwalk(t))  # number of internal nodes</code></pre><pre><code class="language-none">17</code></pre></div><p>Now we add two WGD nodes to the tree. We do this by specifying the last common ancestor node for the lineages that share the hypothetical WGD. By default, the added node is halfway between the specified node and its parent.</p><div><pre><code class="language-julia">insertnode!(getlca(t, &quot;PPAT&quot;, &quot;PPAT&quot;), name=&quot;wgd_1&quot;)
insertnode!(getlca(t, &quot;ATHA&quot;, &quot;ATRI&quot;), name=&quot;wgd_2&quot;)</code></pre><pre><code class="language-none">0.6125</code></pre></div><p>and we obtain a reference model object, using the constant-rates model with two WGDs</p><div><pre><code class="language-julia">θ = ConstantDLWGD(λ=0.1, μ=0.2, q=[0.2, 0.1], η=0.9)
r = Whale.RatesModel(θ, fixed=(:p,))
w = WhaleModel(r, t, .1)</code></pre><pre><code class="language-none">WhaleModel
——————————
⋅Parameterization:
RatesModel with (:p,) fixed
ConstantDLWGD{Float64,Float64}
  λ: Float64 0.1
  μ: Float64 0.2
  q: Array{Float64}((2,)) [0.2, 0.1]
  p: Array{Float64}((0,)) Float64[]
  η: Float64 0.9

⋅Condition:
Whale.RootCondition

⋅Model structure:
19 nodes (9 leaves, 2 WGD nodes)
node_id,wgd_id,distance,Δt,n,subtree
1,0,4.752,0.099,48,&quot;MPOL;&quot;
2,0,2.376,0.099,24,&quot;PPAT;&quot;
3,0,4.457,0.099,45,&quot;SMOE;&quot;
4,0,3.178,0.0993,32,&quot;GBIL;&quot;
5,0,3.178,0.0993,32,&quot;PABI;&quot;
6,0,1.555,0.0972,16,&quot;OSAT;&quot;
7,0,0.5548,0.0925,6,&quot;ATHA;&quot;
8,0,0.5548,0.0925,6,&quot;CPAP;&quot;
9,0,2.293,0.0997,23,&quot;ATRI;&quot;
18,1,2.376,0.099,24,&quot;(PPAT);&quot;
10,0,0.292,0.0584,5,&quot;(MPOL,(PPAT));&quot;
11,0,0.34,0.068,5,&quot;(GBIL,PABI);&quot;
12,0,1.0002,0.0909,11,&quot;(ATHA,CPAP);&quot;
13,0,0.738,0.0922,8,&quot;(OSAT,(ATHA,CPAP));&quot;
14,0,0.6125,0.0875,7,&quot;((OSAT,(ATHA,CPAP)),ATRI);&quot;
19,2,0.6125,0.0875,7,&quot;(((OSAT,(ATHA,CPAP)),ATRI));&quot;
15,0,0.939,0.0939,10,&quot;((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI)));&quot;
16,0,0.587,0.0978,6,&quot;(SMOE,((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI))));&quot;
17,0,0.0,0.0,0,&quot;((MPOL,(PPAT)),(SMOE,((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI)))));&quot;</code></pre></div><p>next we get the data (we need a model object for that)</p><div><pre><code class="language-julia">ccd = read_ale(joinpath(@__DIR__, &quot;../../example/example-1/ale&quot;), w)</code></pre><pre><code class="language-none">12-element Array{CCD{UInt16,Float64},1}:
 CCD{UInt16,Float64}(Γ=83, 𝓛=13)
 CCD{UInt16,Float64}(Γ=55, 𝓛=13)
 CCD{UInt16,Float64}(Γ=89, 𝓛=13)
 CCD{UInt16,Float64}(Γ=131, 𝓛=13)
 CCD{UInt16,Float64}(Γ=107, 𝓛=13)
 CCD{UInt16,Float64}(Γ=59, 𝓛=13)
 CCD{UInt16,Float64}(Γ=53, 𝓛=13)
 CCD{UInt16,Float64}(Γ=83, 𝓛=13)
 CCD{UInt16,Float64}(Γ=59, 𝓛=13)
 CCD{UInt16,Float64}(Γ=95, 𝓛=13)
 CCD{UInt16,Float64}(Γ=67, 𝓛=13)
 CCD{UInt16,Float64}(Γ=65, 𝓛=13)</code></pre></div><p>Now we define the Turing model</p><pre><code class="language-">@model constantrates(model, ccd) = begin
    r  ~ MvLogNormal(ones(2))  # prior on the duplication and loss rate
    η  ~ Beta(3,1)  # hyperprior for the parameter of the geometric prior distribution on the number of genes at the root of the species tree
    q1 ~ Beta()  # prior for the WGD retention rate of `wgd_1`
    q2 ~ Beta()  # prior for the WGD retention rate of `wgd_2`
    ccd ~ model((λ=r[1], μ=r[2], η=η, q=[q1, q2]))
end

model = constantrates(w, ccd)
chain = sample(model, NUTS(0.65), 100)</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Of course such a chain should be run much longer than in this example! Here a very short chain is presented to ensure reasonable build times for this documentation.</p></div></div><h2><a class="nav-anchor" id="Using-a-branch-specific-rates-model-1" href="#Using-a-branch-specific-rates-model-1">Using a branch-specific rates model</a></h2><p>Now we will consider a model with branch-specific duplication and loss rates, using a more complicated hierarchical model with an bivariate uncorrelated relaxed clock prior. We&#39;ll use the same tree as above. The relevant model now is the DLWGD model:</p><div><pre><code class="language-julia">params = DLWGD(λ=randn(n), μ=randn(n), q=rand(2), η=rand())
r = Whale.RatesModel(params, fixed=(:p,))
w = WhaleModel(r, t, 0.5)
ccd = read_ale(joinpath(@__DIR__, &quot;../../example/example-1/ale&quot;), w)</code></pre><pre><code class="language-none">12-element Array{CCD{UInt16,Float64},1}:
 CCD{UInt16,Float64}(Γ=83, 𝓛=13)
 CCD{UInt16,Float64}(Γ=55, 𝓛=13)
 CCD{UInt16,Float64}(Γ=89, 𝓛=13)
 CCD{UInt16,Float64}(Γ=131, 𝓛=13)
 CCD{UInt16,Float64}(Γ=107, 𝓛=13)
 CCD{UInt16,Float64}(Γ=59, 𝓛=13)
 CCD{UInt16,Float64}(Γ=53, 𝓛=13)
 CCD{UInt16,Float64}(Γ=83, 𝓛=13)
 CCD{UInt16,Float64}(Γ=59, 𝓛=13)
 CCD{UInt16,Float64}(Γ=95, 𝓛=13)
 CCD{UInt16,Float64}(Γ=67, 𝓛=13)
 CCD{UInt16,Float64}(Γ=65, 𝓛=13)</code></pre></div><p>Note that the duplication and loss rates should here be specified on a log-scale for the DLWGD model. We use an LKJ prior for the covariance matrix, specifying a prior for the correlation of duplication and loss rates (<code>ρ</code>) and a prior for the scale parameter <code>τ</code> (see e.g. the <a href="https://mc-stan.org/docs/2_23/stan-users-guide/multivariate-hierarchical-priors-section.html">stan docs</a>):</p><pre><code class="language-">@model branchrates(model, ccd, ::Type{T}=Matrix{Float64}) where {T} = begin
    η ~ Beta(3,1)
    ρ ~ Uniform(-1, 1.)
    τ ~ truncated(Cauchy(0, 1), 0, Inf)
    S = [τ 0. ; 0. τ]
    R = [1. ρ ; ρ 1.]
    Σ = S*R*S
    !isposdef(Σ) &amp;&amp; return -Inf
    r = T(undef, 2, n)
    r[:,1] ~ MvNormal(zeros(2), ones(2))
    for i=2:n
        r[:,i] ~ MvNormal(r[:,1], Σ)
    end
    q1 ~ Beta()
    q2 ~ Beta()
    ccd ~ model((λ=r[1,:], μ=r[2,:], η=η, q=[q1, q2]))
end

model = branchrates(w, ccd)
chain = sample(model, NUTS(0.65), 100)</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Of course such a chain should be run much longer than in this example! Here a very short chain is presented to ensure reasonable build times for this documentation.</p></div></div><p>Now let&#39;s obtain reconciled trees</p><pre><code class="language-">pdf = DataFrame(chain)
fun = (m, x)-&gt; Array(x) |&gt; x-&gt;m((λ=x[3:2:36], μ=x[4:2:36], η=x[end-2], q=x[1:2]))
tt = TreeTracker(w, ccd[end-1:end], pdf, fun)
trees = track(tt)</code></pre><p>Let&#39;s have a look at the first family</p><pre><code class="language-">trees[1].trees</code></pre><p>Or maybe all the gene pairs</p><pre><code class="language-">ps = Whale.getpairs(trees, w);
nothing #hide</code></pre><p>Now let&#39;s look at the gene pairs which have a non-zero posterior probability of being derived from WGD node 18 (the <em>P. patens</em> WGD, execute <code>@show w</code> to check the model structure)</p><pre><code class="language-">p = filter(x-&gt;x[Symbol(&quot;18_wgd&quot;)] &gt; 0.0, ps)[!,:pair]</code></pre><p>The full (approximate) probability distribution over reconciliation events for this gene pair is</p><pre><code class="language-">row = ps[ps[!,:pair] .== p[1],1:end-2]
for (k,v) in zip(names(row), Array(row))
    v &gt; 0. &amp;&amp; println(k, &quot;: &quot;, v)
end</code></pre><p>The following can also be helpful</p><pre><code class="language-">tables = Whale.getwgdtables(trees, ccd, w)
tables</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../wgd-dhmc/"><span class="direction">Previous</span><span class="title">Bayesian inference using NUTS with <code>DynamicHMC.jl</code></span></a><a class="next" href="../cytp450/"><span class="direction">Next</span><span class="title">Reconciled tree inference example</span></a></footer></article></body></html>
